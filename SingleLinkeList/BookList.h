#ifndef BOOK_LIST_HEADER
#define BOOK_LIST_HEADER

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#include "BookInfo.h"

//Тип вузла списку.
typedef struct Tnode
{
	TbookInfo m_info;
	struct Tnode *m_pNext;
}Tnode;
//--------------------------------------------------------------------------------
//Створює новий вузол, у динамічній пам'яті.
//Створений елемент повинен  видалений з памяті,
//коли він стає не потрібним.
//Якщо ви вставили його в список, то це можна зробити видаливши
//весь список(DeleteList).Інакше зробіть це за допомогою free.
//Поля будуть мати такі значення:
//m_pNext = NULL,m_info = info.
//Приклад:
//ТbookInfo info = {"Val","Nat",1900,60,20.25};
//Tnode* listNode = CreateNew(info);
//...
//free(listNode);
Tnode* CreateNew(TbookInfo info);
//--------------------------------------------------------------------------------
//Створює новий вузол списк з вмісто info.
//Потім вставляє його у список за проти алфавітним порядком.
//Поветає 0 ,якщо ppList == NULL, інакше повертає 1. 
int InsertNewInOrder(Tnode** list, TbookInfo info);
//--------------------------------------------------------------------------------
//Видаляє всі книжки з кількістю сторінок менше 50ти.
//Повертає 0 ,якщо ppList == NULL або *ppList == NULL,інакше
//повертає 1
int DeleteLess50Pages(Tnode** ppList);
//--------------------------------------------------------------------------------
///Cтворю масив що містить 5 найновіших книг, повертає його.
//Якщо список має менше елементів за 5, то функція повертає NULL.
//Масив , що буде повернутий потрібно звільнити.
//Приклад:
//TbookInfo* pTop5Books =  FindTop5Latest(const Tnode* ppList);
//...
//free(pTopBooks);
TbookInfo* FindTop5Latest(const Tnode* pList);
//--------------------------------------------------------------------------------
//Видаляє список.
//Якщо ppList == NULL повертає 0, інакше 1.
//Після виклику *ppList == NULL.
int DeleteList(Tnode** ppList);
//--------------------------------------------------------------------------------
//Виводить список у вигляді таблиці з видимими рамками
void PrintListBooks(const Tnode* pList);
//--------------------------------------------------------------------------------
//Видаляє елемен ,що переданий, не міняючи вказівники попередніх елементів.
//Повертає 0 ,якщо ppHeadOList == NULL, або список пустий. 
int DeleteHead(Tnode** ppHeadOfList);
//--------------------------------------------------------------------------------
//Рахує кількість вузлів у списку.
int CountNodes(const Tnode* pList);
//--------------------------------------------------------------------------------
//Вставляє pNode на початок cписку.
//Повертає 0 ,якщо ppList == NULL або pNode == NULL,
//інакше повертає 1.
int InsertToBegin(Tnode** ppList, Tnode* pNode);
//--------------------------------------------------------------------------------
#endif